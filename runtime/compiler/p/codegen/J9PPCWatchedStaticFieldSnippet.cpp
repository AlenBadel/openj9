/*******************************************************************************
 * Copyright (c) 2019, 2019 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this
 * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
 * or the Apache License, Version 2.0 which accompanies this distribution and
 * is available at https://www.apache.org/licenses/LICENSE-2.0.
 *
 * This Source Code may also be made available under the following
 * Secondary Licenses when the conditions for such availability set
 * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
 * General Public License, version 2 with the GNU Classpath
 * Exception [1] and GNU General Public License, version 2 with the
 * OpenJDK Assembly Exception [2].
 *
 * [1] https://www.gnu.org/software/classpath/license.html
 * [2] http://openjdk.java.net/legal/assembly-exception.html
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
 *******************************************************************************/

#include "codegen/J9PPCWatchedStaticFieldSnippet.hpp"
#include "codegen/Relocation.hpp"
#include "p/codegen/PPCTableOfConstants.hpp"


uint8_t* TR::J9PPCWatchedStaticFieldSnippet::emitSnippetBody()
    {
    uint8_t *cursor = cg()->getBinaryBufferCursor();
    getSnippetLabel()->setCodeLocation(cursor);
    TR::Node *node = getNode();

    /* We emit the dataSnippet based on the assumption that the J9JITWatchedStaticFieldData structure is laid out as below:
    typedef struct J9JITWatchedStaticFieldData {
            J9Method *method;               // Currently executing method
            UDATA location;                 // Bytecode PC index
            void *fieldAddress;             // Address of static field storage
            J9Class *fieldClass;            // Declaring class of static field
    } J9JITWatchedStaticFieldData;
    */

    // Emit each field and add a relocation record (for AOT compiles) for any field if needed.
    J9JITWatchedStaticFieldData *str = reinterpret_cast<J9JITWatchedStaticFieldData *>(cursor);
    str->method = TR::J9WatchedStaticFieldSnippet::staticFieldData.method;
    str->location = TR::J9WatchedStaticFieldSnippet::staticFieldData.location;
    str->fieldAddress = TR::J9WatchedStaticFieldSnippet::staticFieldData.fieldAddress;
    str->fieldClass = TR::J9WatchedStaticFieldSnippet::staticFieldData.fieldClass;

    if (cg()->comp()->getOption(TR_UseSymbolValidationManager))
        {
        cg()->addExternalRelocation(
            new (cg()->trHeapMemory()) TR::ExternalRelocation(cursor + offsetof(J9JITWatchedStaticFieldData, method), reinterpret_cast<uint8_t *>(staticFieldData.method), reinterpret_cast<uint8_t *>(TR::SymbolType::typeMethod), TR_SymbolFromManager, cg()),
            __FILE__,
            __LINE__,
            node);
        }
    else
        {
        cg()->addExternalRelocation(new (cg()->trHeapMemory()) TR::ExternalRelocation(cursor + offsetof(J9JITWatchedStaticFieldData, method), NULL, TR_RamMethod, cg()), __FILE__, __LINE__, node);
        }

    bool isResolved = !node->getSymbolReference()->isUnresolved();
    // If the field is unresolved then we populate these snippet fields with the correct value at runtime (via the instructions generated by generateFillInDataBlockSequenceForUnresolvedField)
    // and hence don't need to add relocation records here.
    if (isResolved)
        {
        cg()->addExternalRelocation(
            new (cg()->trHeapMemory()) TR::ExternalRelocation(cursor + offsetof(J9JITWatchedStaticFieldData, fieldAddress), reinterpret_cast<uint8_t *>(node->getSymbolReference()), reinterpret_cast<uint8_t *>(node->getInlinedSiteIndex()), TR_DataAddress, cg()),
            __FILE__,
            __LINE__,
            node);
        if (cg()->comp()->getOption(TR_UseSymbolValidationManager))
            {
            cg()->addExternalRelocation(
                new (cg()->trHeapMemory()) TR::ExternalRelocation(cursor + offsetof(J9JITWatchedStaticFieldData, fieldClass), reinterpret_cast<uint8_t *>(staticFieldData.fieldClass), reinterpret_cast<uint8_t *>(TR::SymbolType::typeClass), TR_SymbolFromManager, cg()),
                __FILE__,
                __LINE__,
                node);
            }
        else
            {
            /* Deploy when AOT is Enabled. TR_ClassAddress needs to support contiguous addresses. 
            TR_RelocationRecordInformation *recordInfo = (TR_RelocationRecordInformation *)cg()->comp()->trMemory()->allocateMemory(sizeof(TR_RelocationRecordInformation), heapAlloc);
            recordInfo->data1 = (uintptr_t)(node->getSymbolReference());
            recordInfo->data2 = (uintptr_t)(node->getInlinedSiteIndex());
            recordInfo->data3 = (uintptr_t)(fixedSequence7);
            cg()->addExternalRelocation(
                new (cg()->trHeapMemory()) TR::ExternalRelocation(cursor + offsetof(J9JITWatchedStaticFieldData, fieldClass), (uint8_t *)recordInfo, TR_ClassAddress, cg()),
                __FILE__,
                __LINE__,
                node);
            */
            }
            
        }

        // Insert into TOC 
        if (TR::Compiler->target.is64Bit() && getTOCOffset() != PTOC_FULL_INDEX)
            {
            TR_PPCTableOfConstants::setTOCSlot(getTOCOffset(), (uintptrj_t)cursor);
            }
        else if (getLowerInstruction() != NULL)
            {
            // Handle Nibles - Generation of instructions to materialise address
            int32_t *patchAddr = (int32_t *)getLowerInstruction()->getBinaryEncoding();
            intptrj_t addrValue = (intptrj_t)cursor;

            if (TR::Compiler->target.is64Bit())
                {
                *patchAddr |= LO_VALUE(addrValue) & 0x0000ffff;
                addrValue = cg()->hiValue(addrValue);
                *(patchAddr-2) |= addrValue & 0x0000ffff;
                *(patchAddr-3) |= (addrValue>>16) & 0x0000ffff;
                *(patchAddr-4) |= (addrValue>>32) & 0x0000ffff;
                }
            else
                {
                // 32 Bit only handles nibbles. TOC is not enabled . 
                *(patchAddr) |= cg()->hiValue(addrValue) & 0x0000ffff;
                *(patchAddr-2) |= LO_VALUE(addrValue) & 0x0000ffff;
                }
            }
        
        cursor += sizeof(J9JITWatchedStaticFieldData);
        
        return cursor; 

    }